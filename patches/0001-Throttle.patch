diff -bur gx.orig/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/dht.go gx/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/dht.go
--- gx.orig/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/dht.go	2018-12-14 12:07:52.689849497 +0100
+++ gx/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/dht.go	2018-12-13 18:08:13.571848278 +0100
@@ -37,7 +37,7 @@
 
 // NumBootstrapQueries defines the number of random dht queries to do to
 // collect members of the routing table.
-const NumBootstrapQueries = 5
+//const NumBootstrapQueries = 5
 
 // IpfsDHT is an implementation of Kademlia with S/Kademlia modifications.
 // It is used to implement the base IpfsRouting module.
diff -bur gx.orig/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/dht_net.go gx/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/dht_net.go
--- gx.orig/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/dht_net.go	2018-12-14 12:07:52.689849497 +0100
+++ gx/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/dht_net.go	2018-12-13 18:34:18.067336447 +0100
@@ -23,6 +23,115 @@
 	Flush() error
 }
 
+//---------------------------------------------------
+type RateCounter struct {
+	checkPoint *time.Time
+	writeSize float64 // Since checkPoint
+	maxSpeed float64 // Bytes per second
+	mut  sync.Mutex
+}
+
+func NewRateCounter() *RateCounter {
+	return &RateCounter {
+		nil,
+		0,
+		//2048, // maxSpeed; TODO: Make configurable
+		//4096, // maxSpeed; TODO: Make configurable
+		//8192, // maxSpeed; TODO: Make configurable
+		//16384, // maxSpeed; TODO: Make configurable
+		//32768, // maxSpeed; TODO: Make configurable
+		65536, // maxSpeed; TODO: Make configurable
+		//131072, // maxSpeed; TODO: Make configurable
+		//65536, // maxSpeed; TODO: Make configurable
+		sync.Mutex{},
+	}
+}
+
+//---------------------------------------------------
+type ChokingWriter struct {
+	io.Writer
+	rc *RateCounter
+}
+
+func speedString(speed float64) string {
+	bitspeed := 8*speed
+	if bitspeed < 1000 { return fmt.Sprintf("%fBit/s", bitspeed) }
+	if bitspeed < 1000000 { return fmt.Sprintf("%fkBit/s", bitspeed / 1000) }
+	return fmt.Sprintf("%fMBit/s", bitspeed / 1000000)
+}
+
+var g_c = 0
+var g_m = sync.Mutex{}
+
+func (w *ChokingWriter) Write(p []byte) (int, error) {
+	//g_m.Lock()
+	//g_c += 1
+	//fmt.Printf(">>>>>>>> %d\n", g_c)
+	//defer func () { g_c -= 1}()
+	//g_m.Unlock()
+
+
+	w.rc.mut.Lock()
+	defer w.rc.mut.Unlock()
+
+	now := time.Now();
+
+	if w.rc.checkPoint == nil {
+		n,e := w.Writer.Write(p)
+
+		w.rc.checkPoint = &now
+		w.rc.writeSize = float64(n)
+
+		return n, e
+	}
+
+	interval := 1 * time.Second;
+
+	if d := now.Sub(*w.rc.checkPoint); d > interval {
+		r := interval.Seconds() / d.Seconds()
+		newCheckPoint := now.Add(-1*interval)
+		w.rc.checkPoint = &newCheckPoint
+		w.rc.writeSize = float64(w.rc.writeSize) * r
+	}
+
+	d := now.Sub(*w.rc.checkPoint).Seconds()
+
+	speed_cur := speedString(w.rc.writeSize / d)
+
+	n,e := w.Writer.Write(p)
+
+	if e != nil { return n, e }
+
+	now = time.Now();
+	d = now.Sub(*w.rc.checkPoint).Seconds()
+	w.rc.writeSize += float64(n)
+	speed_after_write := w.rc.writeSize / d;
+
+	sleep := float64(0)
+
+	if speed_after_write > w.rc.maxSpeed {
+		sleep = w.rc.writeSize / w.rc.maxSpeed - d
+		time.Sleep(time.Duration(1000*sleep) * time.Millisecond)
+	}
+
+	//fmt.Printf(">>>> speed: %s -> %s (max: %s) %fs\n", speed_cur, speedString(speed_after_write), speedString(w.rc.maxSpeed), sleep)
+
+	_ = d
+	_ = speed_cur
+	_ = speed_after_write
+	_ = sleep
+	return n, e
+}
+
+func NewChokingWriter(w io.Writer, rc *RateCounter) *ChokingWriter {
+	return &ChokingWriter {
+		Writer: w,
+		rc: rc,
+	}
+}
+
+//---------------------------------------------------
+
 // The Protobuf writer performs multiple small writes when writing a message.
 // We need to buffer those writes, to make sure that we're not sending a new
 // packet for every single write.
@@ -31,7 +140,11 @@
 	ggio.WriteCloser
 }
 
-func newBufferedDelimitedWriter(str io.Writer) bufferedWriteCloser {
+// TODO: This shouldn't be a global var
+var g_cc = NewRateCounter()
+
+func newBufferedDelimitedWriter(str_ io.Writer) bufferedWriteCloser {
+	str := NewChokingWriter(str_, g_cc)
 	w := bufio.NewWriter(str)
 	return &bufferedDelimitedWriter{
 		Writer:      w,
Only in gx/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht: dht_net.go.orig
diff -bur gx.orig/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/routing.go gx/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/routing.go
--- gx.orig/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/routing.go	2018-12-14 12:07:52.693849596 +0100
+++ gx/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/routing.go	2018-12-13 14:30:47.475838961 +0100
@@ -27,7 +27,7 @@
 // buffer allows multiple queries to execute simultaneously, return their
 // results and continue querying closer peers. Note that different query
 // results will wait for the channel to drain.
-var asyncQueryBuffer = 10
+var asyncQueryBuffer = 5 // 10
 
 // This file implements the Routing interface for the IpfsDHT struct.
 
diff -bur gx.orig/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/util.go gx/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/util.go
--- gx.orig/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/util.go	2018-12-14 12:07:26.593180304 +0100
+++ gx/ipfs/QmQHnqaNULV8WeUGgh97o9K3KAW6kWQmDyNf9UuikgnPTe/go-libp2p-kad-dht/util.go	2018-12-13 14:29:20.791185310 +0100
@@ -8,10 +8,10 @@
 var PoolSize = 6
 
 // K is the maximum number of requests to perform before returning failure.
-var KValue = 20
+var KValue = 10 //20
 
 // Alpha is the concurrency factor for asynchronous requests.
-var AlphaValue = 3
+var AlphaValue = 2
 
 // A counter for incrementing a variable across multiple threads
 type counter struct {
diff -bur gx.orig/ipfs/QmVHhT8NxtApPTndiZPe4JNGNUxGWtJe3ebyxtRz4HnbEp/go-libp2p-swarm/swarm_dial.go gx/ipfs/QmVHhT8NxtApPTndiZPe4JNGNUxGWtJe3ebyxtRz4HnbEp/go-libp2p-swarm/swarm_dial.go
--- gx.orig/ipfs/QmVHhT8NxtApPTndiZPe4JNGNUxGWtJe3ebyxtRz4HnbEp/go-libp2p-swarm/swarm_dial.go	2018-12-14 12:07:52.785851914 +0100
+++ gx/ipfs/QmVHhT8NxtApPTndiZPe4JNGNUxGWtJe3ebyxtRz4HnbEp/go-libp2p-swarm/swarm_dial.go	2018-12-14 09:39:59.040401502 +0100
@@ -50,11 +50,11 @@
 
 // ConcurrentFdDials is the number of concurrent outbound dials over transports
 // that consume file descriptors
-const ConcurrentFdDials = 160
+const ConcurrentFdDials = 80 // 160
 
 // DefaultPerPeerRateLimit is the number of concurrent outbound dials to make
 // per peer
-const DefaultPerPeerRateLimit = 8
+const DefaultPerPeerRateLimit = 4 // 8
 
 // dialbackoff is a struct used to avoid over-dialing the same, dead peers.
 // Whenever we totally time out on a peer (all three attempts), we add them
